// OpenAPI client generated by Dynamite. Do not manually edit this file.

// ignore_for_file: camel_case_extensions, camel_case_types, discarded_futures
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: public_member_api_docs, unreachable_switch_case
// ignore_for_file: unused_element

/// Enum tests Version: 0.0.1.
library; // ignore_for_file: no_leading_underscores_for_library_prefixes

import 'package:built_collection/built_collection.dart';
import 'package:built_value/built_value.dart';
import 'package:built_value/serializer.dart';
import 'package:built_value/standard_json_plugin.dart' as _i3;
import 'package:dynamite_runtime/built_value.dart' as _i2;
import 'package:meta/meta.dart' as _i1;

part 'enum.openapi.g.dart';

class EnumString extends EnumClass {
  const EnumString._(super.name);

  /// `test`
  static const EnumString test = _$enumStringTest;

  /// `default`
  @BuiltValueEnumConst(wireName: 'default')
  static const EnumString $default = _$enumString$default;

  /// `$dollar$`
  @BuiltValueEnumConst(wireName: r'$dollar$')
  static const EnumString dollar = _$enumStringDollar;

  /// Returns a set with all values this enum contains.
  static BuiltSet<EnumString> get values => _$enumStringValues;

  /// Returns the enum value associated to the [name].
  static EnumString valueOf(String name) => _$valueOfEnumString(name);

  /// Returns the serialized value of this enum value.
  String get value => _$jsonSerializers.serializeWith(serializer, this)! as String;

  /// Serializer for EnumString.
  @BuiltValueSerializer(custom: true)
  static Serializer<EnumString> get serializer => const _$EnumStringSerializer();
}

class _$EnumStringSerializer implements PrimitiveSerializer<EnumString> {
  const _$EnumStringSerializer();

  static const Map<EnumString, Object> _toWire = <EnumString, Object>{
    EnumString.test: 'test',
    EnumString.$default: 'default',
    EnumString.dollar: r'$dollar$',
  };

  static const Map<Object, EnumString> _fromWire = <Object, EnumString>{
    'test': EnumString.test,
    'default': EnumString.$default,
    r'$dollar$': EnumString.dollar,
  };

  @override
  Iterable<Type> get types => const [EnumString];

  @override
  String get wireName => 'EnumString';

  @override
  Object serialize(
    Serializers serializers,
    EnumString object, {
    FullType specifiedType = FullType.unspecified,
  }) =>
      _toWire[object]!;

  @override
  EnumString deserialize(
    Serializers serializers,
    Object serialized, {
    FullType specifiedType = FullType.unspecified,
  }) =>
      _fromWire[serialized]!;
}

class EnumInt extends EnumClass {
  const EnumInt._(super.name);

  /// `0`
  @BuiltValueEnumConst(wireName: '0')
  static const EnumInt $0 = _$enumInt$0;

  /// `1`
  @BuiltValueEnumConst(wireName: '1')
  static const EnumInt $1 = _$enumInt$1;

  /// `2`
  @BuiltValueEnumConst(wireName: '2')
  static const EnumInt $2 = _$enumInt$2;

  /// Returns a set with all values this enum contains.
  static BuiltSet<EnumInt> get values => _$enumIntValues;

  /// Returns the enum value associated to the [name].
  static EnumInt valueOf(String name) => _$valueOfEnumInt(name);

  /// Returns the serialized value of this enum value.
  int get value => _$jsonSerializers.serializeWith(serializer, this)! as int;

  /// Serializer for EnumInt.
  @BuiltValueSerializer(custom: true)
  static Serializer<EnumInt> get serializer => const _$EnumIntSerializer();
}

class _$EnumIntSerializer implements PrimitiveSerializer<EnumInt> {
  const _$EnumIntSerializer();

  static const Map<EnumInt, Object> _toWire = <EnumInt, Object>{
    EnumInt.$0: 0,
    EnumInt.$1: 1,
    EnumInt.$2: 2,
  };

  static const Map<Object, EnumInt> _fromWire = <Object, EnumInt>{
    0: EnumInt.$0,
    1: EnumInt.$1,
    2: EnumInt.$2,
  };

  @override
  Iterable<Type> get types => const [EnumInt];

  @override
  String get wireName => 'EnumInt';

  @override
  Object serialize(
    Serializers serializers,
    EnumInt object, {
    FullType specifiedType = FullType.unspecified,
  }) =>
      _toWire[object]!;

  @override
  EnumInt deserialize(
    Serializers serializers,
    Object serialized, {
    FullType specifiedType = FullType.unspecified,
  }) =>
      _fromWire[serialized]!;
}

class EnumDynamic extends EnumClass {
  const EnumDynamic._(super.name);

  /// `0`
  @BuiltValueEnumConst(wireName: '0')
  static const EnumDynamic $0 = _$enumDynamic$0;

  /// `string`
  static const EnumDynamic string = _$enumDynamicString;

  /// `false`
  @BuiltValueEnumConst(wireName: 'false')
  static const EnumDynamic $false = _$enumDynamic$false;

  /// Returns a set with all values this enum contains.
  static BuiltSet<EnumDynamic> get values => _$enumDynamicValues;

  /// Returns the enum value associated to the [name].
  static EnumDynamic valueOf(String name) => _$valueOfEnumDynamic(name);

  /// Returns the serialized value of this enum value.
  dynamic get value => _$jsonSerializers.serializeWith(serializer, this)! as dynamic;

  /// Serializer for EnumDynamic.
  @BuiltValueSerializer(custom: true)
  static Serializer<EnumDynamic> get serializer => const _$EnumDynamicSerializer();
}

class _$EnumDynamicSerializer implements PrimitiveSerializer<EnumDynamic> {
  const _$EnumDynamicSerializer();

  static const Map<EnumDynamic, Object> _toWire = <EnumDynamic, Object>{
    EnumDynamic.$0: 0,
    EnumDynamic.string: 'string',
    EnumDynamic.$false: false,
  };

  static const Map<Object, EnumDynamic> _fromWire = <Object, EnumDynamic>{
    0: EnumDynamic.$0,
    'string': EnumDynamic.string,
    false: EnumDynamic.$false,
  };

  @override
  Iterable<Type> get types => const [EnumDynamic];

  @override
  String get wireName => 'EnumDynamic';

  @override
  Object serialize(
    Serializers serializers,
    EnumDynamic object, {
    FullType specifiedType = FullType.unspecified,
  }) =>
      _toWire[object]!;

  @override
  EnumDynamic deserialize(
    Serializers serializers,
    Object serialized, {
    FullType specifiedType = FullType.unspecified,
  }) =>
      _fromWire[serialized]!;
}

class WrappedEnum_$String extends EnumClass {
  const WrappedEnum_$String._(super.name);

  /// `test`
  static const WrappedEnum_$String test = _$wrappedEnum$StringTest;

  /// `default`
  @BuiltValueEnumConst(wireName: 'default')
  static const WrappedEnum_$String $default = _$wrappedEnum$String$default;

  /// Returns a set with all values this enum contains.
  static BuiltSet<WrappedEnum_$String> get values => _$wrappedEnum$StringValues;

  /// Returns the enum value associated to the [name].
  static WrappedEnum_$String valueOf(String name) => _$valueOfWrappedEnum_$String(name);

  /// Returns the serialized value of this enum value.
  String get value => _$jsonSerializers.serializeWith(serializer, this)! as String;

  /// Serializer for WrappedEnum_$String.
  @BuiltValueSerializer(custom: true)
  static Serializer<WrappedEnum_$String> get serializer => const _$WrappedEnum_$StringSerializer();
}

class _$WrappedEnum_$StringSerializer implements PrimitiveSerializer<WrappedEnum_$String> {
  const _$WrappedEnum_$StringSerializer();

  static const Map<WrappedEnum_$String, Object> _toWire = <WrappedEnum_$String, Object>{
    WrappedEnum_$String.test: 'test',
    WrappedEnum_$String.$default: 'default',
  };

  static const Map<Object, WrappedEnum_$String> _fromWire = <Object, WrappedEnum_$String>{
    'test': WrappedEnum_$String.test,
    'default': WrappedEnum_$String.$default,
  };

  @override
  Iterable<Type> get types => const [WrappedEnum_$String];

  @override
  String get wireName => r'WrappedEnum_$String';

  @override
  Object serialize(
    Serializers serializers,
    WrappedEnum_$String object, {
    FullType specifiedType = FullType.unspecified,
  }) =>
      _toWire[object]!;

  @override
  WrappedEnum_$String deserialize(
    Serializers serializers,
    Object serialized, {
    FullType specifiedType = FullType.unspecified,
  }) =>
      _fromWire[serialized]!;
}

class WrappedEnum_Integer extends EnumClass {
  const WrappedEnum_Integer._(super.name);

  /// `0`
  @BuiltValueEnumConst(wireName: '0')
  static const WrappedEnum_Integer $0 = _$wrappedEnumInteger$0;

  /// `1`
  @BuiltValueEnumConst(wireName: '1')
  static const WrappedEnum_Integer $1 = _$wrappedEnumInteger$1;

  /// `2`
  @BuiltValueEnumConst(wireName: '2')
  static const WrappedEnum_Integer $2 = _$wrappedEnumInteger$2;

  /// Returns a set with all values this enum contains.
  static BuiltSet<WrappedEnum_Integer> get values => _$wrappedEnumIntegerValues;

  /// Returns the enum value associated to the [name].
  static WrappedEnum_Integer valueOf(String name) => _$valueOfWrappedEnum_Integer(name);

  /// Returns the serialized value of this enum value.
  int get value => _$jsonSerializers.serializeWith(serializer, this)! as int;

  /// Serializer for WrappedEnum_Integer.
  @BuiltValueSerializer(custom: true)
  static Serializer<WrappedEnum_Integer> get serializer => const _$WrappedEnum_IntegerSerializer();
}

class _$WrappedEnum_IntegerSerializer implements PrimitiveSerializer<WrappedEnum_Integer> {
  const _$WrappedEnum_IntegerSerializer();

  static const Map<WrappedEnum_Integer, Object> _toWire = <WrappedEnum_Integer, Object>{
    WrappedEnum_Integer.$0: 0,
    WrappedEnum_Integer.$1: 1,
    WrappedEnum_Integer.$2: 2,
  };

  static const Map<Object, WrappedEnum_Integer> _fromWire = <Object, WrappedEnum_Integer>{
    0: WrappedEnum_Integer.$0,
    1: WrappedEnum_Integer.$1,
    2: WrappedEnum_Integer.$2,
  };

  @override
  Iterable<Type> get types => const [WrappedEnum_Integer];

  @override
  String get wireName => 'WrappedEnum_Integer';

  @override
  Object serialize(
    Serializers serializers,
    WrappedEnum_Integer object, {
    FullType specifiedType = FullType.unspecified,
  }) =>
      _toWire[object]!;

  @override
  WrappedEnum_Integer deserialize(
    Serializers serializers,
    Object serialized, {
    FullType specifiedType = FullType.unspecified,
  }) =>
      _fromWire[serialized]!;
}

@BuiltValue(instantiable: false)
abstract interface class $WrappedEnumInterface {
  @BuiltValueField(wireName: 'String')
  WrappedEnum_$String get string;
  WrappedEnum_Integer get integer;
}

abstract class WrappedEnum implements $WrappedEnumInterface, Built<WrappedEnum, WrappedEnumBuilder> {
  /// Creates a new WrappedEnum object using the builder pattern.
  factory WrappedEnum([void Function(WrappedEnumBuilder)? b]) = _$WrappedEnum;

  const WrappedEnum._();

  /// Creates a new object from the given [json] data.
  ///
  /// Use [toJson] to serialize it back into json.
  factory WrappedEnum.fromJson(Map<String, dynamic> json) => _$jsonSerializers.deserializeWith(serializer, json)!;

  /// Parses this object into a json like map.
  ///
  /// Use the fromJson factory to revive it again.
  Map<String, dynamic> toJson() => _$jsonSerializers.serializeWith(serializer, this)! as Map<String, dynamic>;

  /// Serializer for WrappedEnum.
  static Serializer<WrappedEnum> get serializer => _$wrappedEnumSerializer;
}

@BuiltValue(instantiable: false)
abstract interface class $EnumReferenceInterface {
  EnumString get string;
}

abstract class EnumReference implements $EnumReferenceInterface, Built<EnumReference, EnumReferenceBuilder> {
  /// Creates a new EnumReference object using the builder pattern.
  factory EnumReference([void Function(EnumReferenceBuilder)? b]) = _$EnumReference;

  const EnumReference._();

  /// Creates a new object from the given [json] data.
  ///
  /// Use [toJson] to serialize it back into json.
  factory EnumReference.fromJson(Map<String, dynamic> json) => _$jsonSerializers.deserializeWith(serializer, json)!;

  /// Parses this object into a json like map.
  ///
  /// Use the fromJson factory to revive it again.
  Map<String, dynamic> toJson() => _$jsonSerializers.serializeWith(serializer, this)! as Map<String, dynamic>;

  /// Serializer for EnumReference.
  static Serializer<EnumReference> get serializer => _$enumReferenceSerializer;
}

// coverage:ignore-start
/// Serializer for all values in this library.
///
/// Serializes values into the `built_value` wire format.
/// See: [$jsonSerializers] for serializing into json.
@_i1.visibleForTesting
final Serializers $serializers = _$serializers;
final Serializers _$serializers = (Serializers().toBuilder()
      ..add(EnumString.serializer)
      ..add(EnumInt.serializer)
      ..add(EnumDynamic.serializer)
      ..addBuilderFactory(const FullType(WrappedEnum), WrappedEnumBuilder.new)
      ..add(WrappedEnum.serializer)
      ..add(WrappedEnum_$String.serializer)
      ..add(WrappedEnum_Integer.serializer)
      ..addBuilderFactory(const FullType(EnumReference), EnumReferenceBuilder.new)
      ..add(EnumReference.serializer))
    .build();

/// Serializer for all values in this library.
///
/// Serializes values into the json. Json serialization is more expensive than the built_value wire format.
/// See: [$serializers] for serializing into the `built_value` wire format.
@_i1.visibleForTesting
final Serializers $jsonSerializers = _$jsonSerializers;
final Serializers _$jsonSerializers = (_$serializers.toBuilder()
      ..add(_i2.DynamiteDoubleSerializer())
      ..addPlugin(_i3.StandardJsonPlugin())
      ..addPlugin(const _i2.HeaderPlugin())
      ..addPlugin(const _i2.ContentStringPlugin()))
    .build();
// coverage:ignore-end
