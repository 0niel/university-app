# Architecture
- Pattern: BLoC + Repository (aligned with https://bloclibrary.dev/architecture). UI/screens use blocs/cubits; blocs depend on repositories; repositories orchestrate remote clients + local storage.
- DI: centralized in `@lib/di/app_scope.dart` via `yx_scope` (`dep`/`asyncDep`). Register new services/repositories there; expose through `AppScope` interface and container. Respect the staged `initializeQueue` (preferences -> package info/firebase/supabase -> hydrated storage -> bloc observer).
- Bootstrapping: entrypoints `@lib/main/main_production.dart` and `@lib/main/main_development.dart` call `bootstrap` (Sentry-wrapped `runZonedGuarded`) and create `AppScopeHolder` (with optional `dev` flag). Always run app inside `ScopeProvider(holder: holder, ...)`.
- Initializers to keep in sync when adding platform/services: `firebase_initializer.dart`, `supabase_initializer.dart`, `shared_preferences_initializer.dart`, `hydrated_storage_initializer.dart`, `package_info_initializer.dart`, `bloc_observer_initializer.dart` (analytics-aware observer). Dispose/close resources if a new initializer is introduced.
- Networking/auth: use `ApiClient` from scope (dev flag uses localhost), `Supabase.instance.client` for auth; store tokens in `token_storage`/`secure_storage` provided by scope. Do not access Supabase or API clients directly without going through the injected repository.
- Persistence/state: hydrated blocs use `CustomHydratedStorage` (shared preferences backed). Keep business logic in blocs, avoid side effects in widgets; surface async work through events/states.
- Observability: errors flow through `Logger` + Sentry (bootstrap) and analytics events go via `AppBlocObserver` (`analytics_repository`). If you add new event-heavy blocs, ensure events are meaningful for analytics.
